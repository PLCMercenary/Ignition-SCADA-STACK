{"version":3,"sources":["opcua-iiot-inject.js"],"names":["module","exports","RED","require","install","coreInject","cron","OPCUAIIoTInject","config","nodes","createNode","this","topic","payload","payloadType","repeat","crontab","once","startDelay","parseFloat","name","injectType","addressSpaceItems","node","interval_id","cronjob","REPEAT_FACTOR","ONE_SECOND","INPUT_TIMEOUT_MILLISECONDS","verboseLog","logMessage","settings","verbose","internalDebugLog","repeaterSetup","_","clearInterval","setInterval","emit","CronJob","msg","nodetype","Object","assign","Number","JSON","parse","Date","now","util","evaluateNodeProperty","error","err","onceTimeout","timeout","close","clearTimeout","stop","httpAdmin","post","auth","needsPermission","req","res","getNode","params","id","sendStatus","toString"],"mappings":"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","file":"../opcua-iiot-inject.js","sourcesContent":["/**\n The BSD 3-Clause License\n\n Copyright 2016,2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2013, 2016 IBM Corp. (node-red)\n All rights reserved.\n node-red-contrib-iiot-opcua\n **/\n'use strict'\n\n/**\n * Inject Node-RED node for OPC UA IIoT nodes.\n *\n * @param RED\n */\n\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreInject = require('./core/opcua-iiot-core-inject')\n  let cron = require('cron')\n\n  function OPCUAIIoTInject (config) {\n    RED.nodes.createNode(this, config)\n\n    this.topic = config.topic\n    this.payload = config.payload\n    this.payloadType = config.payloadType\n    this.repeat = config.repeat\n    this.crontab = config.crontab\n    this.once = config.once\n    this.startDelay = parseFloat(config.startDelay) || 10\n    this.name = config.name\n    this.injectType = config.injectType || 'inject'\n\n    this.addressSpaceItems = config.addressSpaceItems || []\n\n    let node = this\n    node.interval_id = null\n    node.cronjob = null\n    node.REPEAT_FACTOR = 1000.0\n    node.ONE_SECOND = 1000\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n\n    node.verboseLog = function (logMessage) {\n      if (RED.settings.verbose) {\n        coreInject.internalDebugLog(logMessage)\n      }\n    }\n\n    node.repeaterSetup = function () {\n      coreInject.internalDebugLog('Repeat Is ' + node.repeat)\n      coreInject.internalDebugLog('Crontab Is ' + node.crontab)\n\n      if (node.repeat !== '') {\n        node.repeat = parseFloat(config.repeat) * node.REPEAT_FACTOR\n\n        if (node.repeat === 0) {\n          node.repeat = node.ONE_SECOND\n        }\n        node.verboseLog(RED._('opcuaiiotinject.repeat', node))\n        coreInject.internalDebugLog('Repeat Interval Start With ' + node.repeat + ' msec.')\n\n        if (node.interval_id) {\n          clearInterval(node.interval_id)\n        }\n\n        node.interval_id = setInterval(function () {\n          node.emit('input', {})\n        }, node.repeat)\n      } else if (node.crontab !== '') {\n        node.verboseLog(RED._('opcuaiiotinject.crontab', node))\n\n        node.cronjob = new cron.CronJob(node.crontab,\n          function () {\n            node.emit('input', {})\n          },\n          null,\n          true)\n      }\n    }\n\n    node.on('input', function (msg) {\n      try {\n        msg.topic = node.topic\n        msg.nodetype = 'inject'\n        msg.injectType = node.injectType\n        msg.addressSpaceItems = []\n        Object.assign(msg.addressSpaceItems, node.addressSpaceItems)\n\n        switch (node.payloadType) {\n          case 'none':\n            msg.payload = ''\n            break\n          case 'str':\n            msg.payload = node.payload.toString()\n            break\n          case 'num':\n            msg.payload = Number(node.payload)\n            break\n          case 'bool':\n            msg.payload = (node.payload === true || node.payload === 'true')\n            break\n          case 'json':\n            msg.payload = JSON.parse(node.payload)\n            break\n          case 'date':\n            msg.payload = Date.now()\n            break\n          default:\n            if (node.payloadType === null) {\n              if (node.payload === '') {\n                msg.payload = Date.now()\n              } else {\n                msg.payload = node.payload\n              }\n            } else {\n              msg.payload = RED.util.evaluateNodeProperty(node.payload, node.payloadType, this, msg)\n            }\n        }\n\n        node.send(msg)\n      } catch (err) {\n        node.verboseLog(err)\n        if (RED.settings.verbose) {\n          node.error(err, msg)\n        }\n      }\n    })\n\n    if (node.once) {\n      let timeout = parseInt(node.INPUT_TIMEOUT_MILLISECONDS * node.startDelay)\n      coreInject.internalDebugLog('injecting once at start delay timeout ' + timeout + ' msec.')\n      node.onceTimeout = setTimeout(function () {\n        coreInject.internalDebugLog('injecting once at start')\n        node.emit('input', {})\n        node.repeaterSetup()\n      }, timeout)\n    } else {\n      node.repeaterSetup()\n    }\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Inject', OPCUAIIoTInject)\n\n  OPCUAIIoTInject.prototype.close = function () {\n    let node = this\n\n    if (node.onceTimeout) {\n      clearTimeout(node.onceTimeout)\n    }\n\n    if (node.interval_id) {\n      clearInterval(node.interval_id)\n      node.verboseLog(RED._('opcuaiiotinject.stopped'))\n    }\n\n    if (node.cronjob) {\n      node.cronjob.stop()\n      node.verboseLog(RED._('opcuaiiotinject.stopped'))\n      delete node.cronjob\n    }\n  }\n\n  RED.httpAdmin.post('/opcuaIIoT/inject/:id', RED.auth.needsPermission('opcuaIIoT.inject.write'), function (req, res) {\n    let node = RED.nodes.getNode(req.params.id)\n\n    if (node) {\n      try {\n        node.receive()\n        res.sendStatus(200)\n      } catch (err) {\n        res.sendStatus(500)\n        node.error(RED._('opcuaiiotinject.failed', {error: err.toString()}))\n      }\n    } else {\n      res.sendStatus(404)\n    }\n  })\n}\n"]}