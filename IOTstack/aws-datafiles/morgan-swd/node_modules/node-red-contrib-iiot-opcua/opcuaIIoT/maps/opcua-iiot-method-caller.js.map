{"version":3,"sources":["opcua-iiot-method-caller.js"],"names":["module","exports","RED","require","install","coreMethod","nodes","registerType","config","this","objectId","methodId","OPCUAIIoTMethodCaller","createNode","methodType","value","showStatusActivities","justValue","name","inputArguments","getNode","node","connector","sessionTimeout","reconnectTimeout","logMessage","verbose","internalDebugLog","statusLog","settings","verboseLog","setNodeStatusTo","statusValue","statusParameter","core","getNodeStatus","shape","text","status","fill","err","showErrors","handleMethodError","msg","resetBadSession","handleMethodWarn","message","warn","payload","stateMachine","getMachineState","writeDebugLog","opcuaSession","callMethodOnSession","getArgumentDefinition","then","results","JSON","stringify","callMethod","Error","definitionResults","callMethods","data","detailDebugLog","result","outputArguments","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","nodetype","_step","push","statusCode","_iterator","return","dataValuesString","definition","util","setMessageProperty","parse","readResult","_typeof","error","catch","opcuaClient","connectorShutdown","TypeError","setOPCUAConnected","opcuaSessionStarted","on"],"mappings":"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","file":"../opcua-iiot-method-caller.js","sourcesContent":["/*\n The BSD 3-Clause License\n\n Copyright 2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n\n/**\n * OPC UA node representation for Node-RED OPC UA IIoT method call.\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreMethod = require('./core/opcua-iiot-core-method')\n\n  function OPCUAIIoTMethodCaller (config) {\n    RED.nodes.createNode(this, config)\n    this.objectId = config.objectId\n    this.methodId = config.methodId\n    this.methodType = config.methodType\n    this.value = config.value\n    this.justValue = config.justValue\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.inputArguments = config.inputArguments\n    this.connector = RED.nodes.getNode(config.connector)\n\n    let node = this\n    node.reconnectTimeout = 1000\n    node.sessionTimeout = null\n\n    node.verboseLog = function (logMessage) {\n      if (RED.settings.verbose) {\n        coreMethod.internalDebugLog(logMessage)\n      }\n    }\n\n    node.statusLog = function (logMessage) {\n      if (RED.settings.verbose && node.showStatusActivities) {\n        node.verboseLog('Status: ' + logMessage)\n      }\n    }\n\n    node.setNodeStatusTo = function (statusValue) {\n      node.statusLog(statusValue)\n      let statusParameter = coreMethod.core.getNodeStatus(statusValue, node.showStatusActivities)\n      node.status({fill: statusParameter.fill, shape: statusParameter.shape, text: statusParameter.status})\n    }\n\n    node.handleMethodError = function (err, msg) {\n      coreMethod.internalDebugLog(err)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      if (coreMethod.core.isSessionBad(err)) {\n        node.connector.resetBadSession()\n      }\n    }\n\n    node.handleMethodWarn = function (message) {\n      if (node.showErrors) {\n        node.warn(message)\n      }\n\n      coreMethod.internalDebugLog(message)\n    }\n\n    node.on('input', function (msg) {\n      let message = msg\n\n      message.objectId = msg.payload.objectId || node.objectId\n      message.methodId = msg.payload.methodId || node.methodId\n      message.methodType = msg.payload.methodType || node.methodType\n      message.inputArguments = msg.payload.inputArguments || node.inputArguments\n      message.nodetype = 'method'\n\n      if (!message.objectId) {\n        node.handleMethodWarn('No Object-Id Found For Method Call')\n        return\n      }\n\n      if (!message.methodId) {\n        node.handleMethodWarn('No Method-Id Found For Method Call')\n        return\n      }\n\n      if (!message.inputArguments) {\n        node.handleMethodWarn('No Input Arguments Found For Method Call')\n        return\n      }\n\n      if (!message.methodType) {\n        node.handleMethodWarn('No Method Type Found For Method Call')\n        return\n      }\n\n      if (node.connector.stateMachine.getMachineState() !== 'OPEN') {\n        coreMethod.writeDebugLog('Client State Not Open On Write')\n        if (node.showErrors) {\n          node.error(new Error('Client Not Open On Wirte'), msg)\n        }\n        return\n      }\n\n      if (node.opcuaSession) {\n        node.callMethodOnSession(message)\n      } else {\n        node.handleMethodWarn('Session Not Ready For Method Call')\n      }\n    })\n\n    node.callMethodOnSession = function (msg) {\n      if (msg.methodId && msg.inputArguments) {\n        coreMethod.getArgumentDefinition(node.opcuaSession, msg).then(function (results) {\n          coreMethod.detailDebugLog('Call Argument Definition Results: ' + JSON.stringify(results))\n          node.callMethod(msg, results)\n        }).catch(node.handleMethodError)\n      } else {\n        coreMethod.internalDebugLog(new Error('No Method Id And/Or Parameters'))\n      }\n    }\n\n    node.callMethod = function (msg, definitionResults) {\n      coreMethod.callMethods(node.opcuaSession, msg).then(function (data) {\n        coreMethod.detailDebugLog('Methods Call Results: ' + JSON.stringify(data))\n\n        let result = null\n        let outputArguments = []\n        let message = data.msg\n        message.nodetype = 'method'\n        message.methodType = data.msg.methodType\n\n        for (result of data.results) {\n          outputArguments.push({statusCode: result.statusCode, outputArguments: result.outputArguments})\n        }\n\n        let dataValuesString = {}\n        if (node.justValue) {\n          if (message.inputArguments) {\n            delete message['inputArguments']\n          }\n          dataValuesString = JSON.stringify(outputArguments, null, 2)\n        } else {\n          dataValuesString = JSON.stringify({\n            results: data.results,\n            definition: definitionResults\n          }, null, 2)\n        }\n\n        try {\n          RED.util.setMessageProperty(message, 'payload', JSON.parse(dataValuesString))\n        } catch (err) {\n          if (node.showErrors) {\n            node.warn('JSON not to parse from string for dataValues type ' + typeof readResult)\n            node.error(err, msg)\n          }\n          message.payload = dataValuesString\n          message.error = err.message\n        }\n\n        node.send(message)\n      }).catch(function (err) {\n        coreMethod.internalDebugLog(err)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n      })\n    }\n\n    node.setOPCUAConnected = function (opcuaClient) {\n      node.opcuaClient = opcuaClient\n      node.setNodeStatusTo('connected')\n    }\n\n    node.opcuaSessionStarted = function (opcuaSession) {\n      node.opcuaSession = opcuaSession\n      node.setNodeStatusTo('active')\n    }\n\n    node.connectorShutdown = function (opcuaClient) {\n      coreMethod.internalDebugLog('Connector Shutdown')\n      if (opcuaClient) {\n        node.opcuaClient = opcuaClient\n      }\n    }\n\n    if (node.connector) {\n      node.connector.on('connected', node.setOPCUAConnected)\n      node.connector.on('session_started', node.opcuaSessionStarted)\n      node.connector.on('after_reconnection', node.connectorShutdown)\n    } else {\n      throw new TypeError('Connector Not Valid')\n    }\n\n    coreMethod.core.setNodeInitalState(node.connector.stateMachine.getMachineState(), node)\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Method-Caller', OPCUAIIoTMethodCaller)\n}\n"]}