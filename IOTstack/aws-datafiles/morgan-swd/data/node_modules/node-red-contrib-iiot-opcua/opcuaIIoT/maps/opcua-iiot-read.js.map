{"version":3,"sources":["opcua-iiot-read.js"],"names":["module","exports","RED","install","require","node","opcuaSession","config","nodes","OPCUAIIoTRead","createNode","attributeId","this","maxAge","depth","name","justValue","showStatusActivities","showErrors","parseStrings","connector","reconnectTimeout","sessionTimeout","opcuaClient","statusLog","logMessage","verbose","coreClient","settings","setNodeStatusTo","statusValue","core","getNodeStatus","statusParameter","shape","status","handleReadError","err","msg","isSessionBad","readFromSession","session","itemsToRead","parseInt","readAllAttributes","then","readResult","send","buildResultMessage","catch","readVariableValue","message","historyDate","Date","getDate","historyStart","readHistoryValue","historyEnd","item","transformedItem","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","nodeId","value","Number","transformedItemsToRead","push","return","read","readType","payload","nodetype","readtype","dataValuesString","JSON","stringify","results","util","setMessageProperty","parse","warn","error","resultsConverted","stateMachine","getMachineState","readDebugLog","Error","buildNodesToRead","setOPCUAConnected","on","connectorShutdown","setNodeInitalState"],"mappings":"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","file":"../opcua-iiot-read.js","sourcesContent":["/*\n The BSD 3-Clause License\n\n Copyright 2016,2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc. (node-red-contrib-opcua)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n\n/**\n * Read Node-RED node.\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreClient = require('./core/opcua-iiot-core-client')\n\n  function OPCUAIIoTRead (config) {\n    RED.nodes.createNode(this, config)\n    this.attributeId = config.attributeId || 0\n    this.maxAge = config.maxAge || 1\n    this.depth = config.depth || 1\n    this.name = config.name\n    this.justValue = config.justValue\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.parseStrings = config.parseStrings\n    this.connector = RED.nodes.getNode(config.connector)\n\n    let node = this\n    node.reconnectTimeout = 1000\n    node.sessionTimeout = null\n    node.opcuaClient = null\n    node.opcuaSession = null\n\n    node.statusLog = function (logMessage) {\n      if (RED.settings.verbose && node.showStatusActivities) {\n        coreClient.readDebugLog('Status: ' + logMessage)\n      }\n    }\n\n    node.setNodeStatusTo = function (statusValue) {\n      node.statusLog(statusValue)\n      let statusParameter = coreClient.core.getNodeStatus(statusValue, node.showStatusActivities)\n      node.status({fill: statusParameter.fill, shape: statusParameter.shape, text: statusParameter.status})\n    }\n\n    node.handleReadError = function (err, msg) {\n      coreClient.readDebugLog(err)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      if (coreClient.core.isSessionBad(err)) {\n        node.connector.resetBadSession()\n      }\n    }\n\n    node.readFromSession = function (session, itemsToRead, msg) {\n      coreClient.readDebugLog('Read With AttributeId ' + node.attributeId)\n\n      switch (parseInt(node.attributeId)) {\n        case 0:\n          coreClient.readAllAttributes(session, itemsToRead).then(function (readResult) {\n            try {\n              node.send(node.buildResultMessage(msg, 'AllAttributes', readResult))\n            } catch (err) {\n              node.handleReadError(err, msg)\n            }\n          }).catch(function (err) {\n            node.handleReadError(err, msg)\n          })\n          break\n        case 13:\n          coreClient.readVariableValue(session, itemsToRead).then(function (readResult) {\n            try {\n              let message = node.buildResultMessage(msg, 'VariableValue', readResult)\n              node.send(message)\n            } catch (err) {\n              node.handleReadError(err, msg)\n            }\n          }).catch(function (err) {\n            node.handleReadError(err, msg)\n          })\n          break\n        case 130:\n          let historyDate = new Date()\n          node.historyStart = new Date(historyDate.getDate() - 1)\n          node.historyEnd = historyDate\n\n          coreClient.readHistoryValue(session, itemsToRead, node.historyStart, node.historyEnd).then(function (readResult) {\n            try {\n              let message = node.buildResultMessage(msg, 'HistoryValue', readResult)\n              message.historyStart = node.historyStart\n              message.historyEnd = node.historyEnd\n              node.send(message)\n            } catch (err) {\n              node.handleReadError(err, msg)\n            }\n          }).catch(function (err) {\n            node.handleReadError(err, msg)\n          })\n          break\n        default:\n          let item = null\n          let transformedItem = null\n          let transformedItemsToRead = []\n\n          for (item of itemsToRead) {\n            transformedItem = {\n              nodeId: item,\n              attributeId: Number(node.attributeId) || null\n            }\n            transformedItemsToRead.push(transformedItem)\n          }\n\n          coreClient.read(session, transformedItemsToRead, node.maxAge).then(function (readResult) {\n            try {\n              let message = node.buildResultMessage(msg, 'Default', readResult)\n              message.maxAge = node.maxAge\n              node.send(message)\n            } catch (err) {\n              node.handleReadError(err, msg)\n            }\n          }).catch(function (err) {\n            node.handleReadError(err, msg)\n          })\n      }\n    }\n\n    node.buildResultMessage = function (msg, readType, readResult) {\n      let message = msg\n      message.payload = {}\n      message.nodetype = 'read'\n      message.readtype = readType\n      message.attributeId = node.attributeId\n\n      let dataValuesString = {}\n      if (node.justValue) {\n        dataValuesString = JSON.stringify(readResult.results, null, 2)\n      } else {\n        dataValuesString = JSON.stringify(readResult, null, 2)\n      }\n\n      try {\n        RED.util.setMessageProperty(message, 'payload', JSON.parse(dataValuesString))\n      } catch (err) {\n        if (node.showErrors) {\n          node.warn('JSON not to parse from string for dataValues type ' + JSON.stringify(readResult, null, 2))\n          node.error(err, msg)\n        }\n\n        message.payload = dataValuesString\n        message.error = err.message\n      }\n\n      if (!node.justValue) {\n        try {\n          message.resultsConverted = {}\n          let dataValuesString = JSON.stringify(readResult.results, null, 2)\n          RED.util.setMessageProperty(message, 'resultsConverted', JSON.parse(dataValuesString))\n        } catch (err) {\n          if (node.showErrors) {\n            node.warn('JSON not to parse from string for dataValues type ' + readResult.results)\n            node.error(err, msg)\n          }\n\n          message.resultsConverted = null\n          message.error = err.message\n        }\n      }\n\n      return message\n    }\n\n    node.on('input', function (msg) {\n      if (node.connector.stateMachine.getMachineState() !== 'OPEN') {\n        coreClient.readDebugLog('Client State Not Open On Read')\n        if (node.showErrors) {\n          node.error(new Error('Client Not Open On Read'), msg)\n        }\n        return\n      }\n\n      if (!node.opcuaSession) {\n        node.error(new Error('Session Not Ready To Read'), msg)\n        return\n      }\n\n      node.readFromSession(node.opcuaSession, coreClient.core.buildNodesToRead(msg), msg)\n    })\n\n    node.setOPCUAConnected = function (opcuaClient) {\n      node.opcuaClient = opcuaClient\n      node.setNodeStatusTo('connected')\n    }\n\n    node.opcuaSessionStarted = function (opcuaSession) {\n      node.opcuaSession = opcuaSession\n      node.setNodeStatusTo('active')\n    }\n\n    node.connectorShutdown = function (opcuaClient) {\n      coreClient.readDebugLog('Connector Shutdown')\n      if (opcuaClient) {\n        node.opcuaClient = opcuaClient\n      }\n    }\n\n    if (node.connector) {\n      node.connector.on('connected', node.setOPCUAConnected)\n      node.connector.on('session_started', node.opcuaSessionStarted)\n      node.connector.on('after_reconnection', node.connectorShutdown)\n    } else {\n      throw new TypeError('Connector Not Valid')\n    }\n\n    coreClient.core.setNodeInitalState(node.connector.stateMachine.getMachineState(), node)\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Read', OPCUAIIoTRead)\n}\n"]}