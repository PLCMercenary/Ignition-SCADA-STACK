{"version":3,"sources":["opcua-iiot-write.js"],"names":["module","exports","RED","require","install","coreClient","setNodeInitalState","config","this","name","justValue","OPCUAIIoTWrite","nodes","showStatusActivities","showErrors","connector","node","sessionTimeout","reconnectTimeout","opcuaClient","logMessage","opcuaSession","verbose","writeDebugLog","statusLog","settings","verboseLog","setNodeStatusTo","statusValue","statusParameter","core","getNodeStatus","shape","text","status","fill","err","handleWriteError","msg","resetBadSession","writeToSession","session","sessionId","buildNodesToWrite","write","nodesToWrite","then","writeResult","message","buildResultMessage","catch","Error","result","nodetype","dataValuesString","JSON","stringify","statusCodes","util","setMessageProperty","parse","_typeof","warn","error","on","stateMachine","getMachineState","injectType","setOPCUAConnected","connectorShutdown","opcuaSessionStarted","TypeError"],"mappings":"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","file":"../opcua-iiot-write.js","sourcesContent":["/*\n The BSD 3-Clause License\n\n Copyright 2016,2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc. (node-red-contrib-opcua)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n\n/**\n * Write Node-RED node.\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreClient = require('./core/opcua-iiot-core-client')\n\n  function OPCUAIIoTWrite (config) {\n    RED.nodes.createNode(this, config)\n    this.name = config.name\n    this.justValue = config.justValue\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connector = RED.nodes.getNode(config.connector)\n\n    let node = this\n    node.reconnectTimeout = 1000\n    node.sessionTimeout = null\n    node.opcuaClient = null\n    node.opcuaSession = null\n\n    node.verboseLog = function (logMessage) {\n      if (RED.settings.verbose) {\n        coreClient.writeDebugLog(logMessage)\n      }\n    }\n\n    node.statusLog = function (logMessage) {\n      if (RED.settings.verbose && node.showStatusActivities) {\n        node.verboseLog('Status: ' + logMessage)\n      }\n    }\n\n    node.setNodeStatusTo = function (statusValue) {\n      node.statusLog(statusValue)\n      let statusParameter = coreClient.core.getNodeStatus(statusValue, node.showStatusActivities)\n      node.status({fill: statusParameter.fill, shape: statusParameter.shape, text: statusParameter.status})\n    }\n\n    node.handleWriteError = function (err, msg) {\n      coreClient.writeDebugLog(err)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      if (coreClient.core.isSessionBad(err)) {\n        node.connector.resetBadSession()\n      }\n    }\n\n    node.writeToSession = function (session, msg) {\n      if (session) {\n        if (session.sessionId === 'terminated') {\n          node.handleWriteError(new Error('Session Terminated'), msg)\n        } else {\n          let nodesToWrite = coreClient.core.buildNodesToWrite(msg)\n\n          coreClient.write(session, nodesToWrite).then(function (writeResult) {\n            try {\n              let message = node.buildResultMessage(msg, writeResult)\n              node.send(message)\n            } catch (err) {\n              node.handleWriteError(err, msg)\n            }\n          }).catch(function (err) {\n            node.handleWriteError(err, msg)\n          })\n        }\n      } else {\n        node.handleWriteError(new Error('Session Not Valid On Write'), msg)\n      }\n    }\n\n    node.buildResultMessage = function (msg, result) {\n      let message = msg\n      msg.nodetype = 'write'\n\n      let dataValuesString = {}\n      if (node.justValue) {\n        dataValuesString = JSON.stringify({\n          statusCodes: result.statusCodes\n        }, null, 2)\n\n        if (message.valuesToWrite) {\n          delete message['valuesToWrite']\n        }\n      } else {\n        dataValuesString = JSON.stringify(result, null, 2)\n      }\n\n      try {\n        RED.util.setMessageProperty(message, 'payload', JSON.parse(dataValuesString))\n      } catch (err) {\n        coreClient.writeDebugLog(err)\n        if (node.showErrors) {\n          node.warn('JSON not to parse from string for write statusCodes type ' + typeof result.statusCodes)\n          node.error(err, msg)\n        }\n        message.resultsConverted = dataValuesString\n        message.error = err.message\n      }\n\n      return message\n    }\n\n    node.on('input', function (msg) {\n      if (node.connector.stateMachine.getMachineState() !== 'OPEN') {\n        coreClient.writeDebugLog('Client State Not Open On Write')\n        if (node.showErrors) {\n          node.error(new Error('Client Not Open On Wirte'), msg)\n        }\n        return\n      }\n\n      if (!node.opcuaSession) {\n        coreClient.writeDebugLog('Session Not Ready To Write')\n        if (node.showErrors) {\n          node.error(new Error('Session Not Ready To Write'), msg)\n        }\n        return\n      }\n\n      if (msg.injectType === 'write') {\n        node.writeToSession(node.opcuaSession, msg)\n      }\n    })\n\n    node.setOPCUAConnected = function (opcuaClient) {\n      node.opcuaClient = opcuaClient\n      node.setNodeStatusTo('connected')\n    }\n\n    node.opcuaSessionStarted = function (opcuaSession) {\n      node.opcuaSession = opcuaSession\n      node.setNodeStatusTo('active')\n    }\n\n    node.connectorShutdown = function (opcuaClient) {\n      coreClient.writeDebugLog('Connector Shutdown')\n      if (opcuaClient) {\n        node.opcuaClient = opcuaClient\n      }\n    }\n\n    if (node.connector) {\n      node.connector.on('connected', node.setOPCUAConnected)\n      node.connector.on('session_started', node.opcuaSessionStarted)\n      node.connector.on('after_reconnection', node.connectorShutdown)\n    } else {\n      throw new TypeError('Connector Not Valid')\n    }\n\n    coreClient.core.setNodeInitalState(node.connector.stateMachine.getMachineState(), node)\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Write', OPCUAIIoTWrite)\n}\n"]}