{"version":3,"sources":["opcua-iiot-result-filter.js"],"names":["module","exports","RED","require","install","coreFilter","nodes","registerType","config","_","this","nodeId","datatype","OPCUAIIoTResultFilter","createNode","fixedValue","fixPoint","parseInt","withPrecision","precision","entry","justValue","withValueCheck","minvalue","maxvalue","defaultvalue","node","showErrors","subscribed","convertDataType","nodeIdToFilter","msg","status","fill","nodeList","core","buildNodesToRead","doFilter","elementNodeId","some","element","index","array","length","toString","on","hasOwnProperty","payload","undefined","addressSpaceItems","topic","filtertype","result","nodetype","filterByWriteType","filterByListenType","internalDebugLog","value","resultDataType","_typeof","error","Error","Number","parseFloat","toFixed","toPrecision","err","send","input","JSON","stringify","filterByReadType","extractValueFromOPCUAStructure","extractValueFromOPCUAArrayStructure","entryIndex","convertDataValueByDataType","text"],"mappings":"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","file":"../opcua-iiot-result-filter.js","sourcesContent":["/*\n The BSD 3-Clause License\n\n Copyright 2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n\n/**\n * OPC UA node representation for Node-RED OPC UA IIoT nodes.\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreFilter = require('./core/opcua-iiot-core-filter')\n  const _ = require('underscore')\n\n  function OPCUAIIoTResultFilter (config) {\n    RED.nodes.createNode(this, config)\n    this.nodeId = config.nodeId\n    this.datatype = config.datatype\n    this.fixedValue = config.fixedValue\n    this.fixPoint = parseInt(config.fixPoint) | 2\n    this.withPrecision = config.withPrecision\n    this.precision = parseInt(config.precision) | 2\n    this.entry = config.entry\n    this.justValue = config.justValue\n    this.withValueCheck = config.withValueCheck\n    this.minvalue = config.minvalue\n    this.maxvalue = config.maxvalue\n    this.defaultvalue = config.defaultvalue\n    this.topic = config.topic\n    this.name = config.name\n    this.showErrors = config.showErrors\n\n    let node = this\n    node.subscribed = false\n\n    if (node.withValueCheck) {\n      node.minvalue = node.convertDataType(node.minvalue)\n      node.maxvalue = node.convertDataType(node.maxvalue)\n    }\n\n    node.status({fill: 'blue', shape: 'ring', text: 'new'})\n\n    node.nodeIdToFilter = function (msg) {\n      let doFilter = true\n      let nodeList = coreFilter.core.buildNodesToRead(msg)\n      let elementNodeId = null\n\n      if (nodeList && nodeList.length) {\n        doFilter = !nodeList.some(function (element, index, array) {\n          elementNodeId = element.nodeId || element\n          return elementNodeId.toString() === node.nodeId.toString()\n        })\n      }\n\n      return doFilter\n    }\n\n    node.on('input', function (msg) {\n      if (!msg.hasOwnProperty('payload') || msg.payload === null || msg.payload === undefined) {\n        coreFilter.internalDebugLog('filtering message without payload ' + JSON.stringify(msg))\n        return\n      }\n\n      if (node.nodeIdToFilter(msg)) {\n        return\n      } else if (msg.addressSpaceItems) {\n        let filteredNodeIds = _.filter(msg.addressSpaceItems, function (entry) {\n          return entry.nodeId === node.nodeId\n        })\n\n        if (filteredNodeIds.length < 1) {\n          return\n        }\n      } else {\n        if (msg.topic !== node.nodeId) { // TODO: that is very old and should be deleted\n          return\n        }\n      }\n\n      msg.filtertype = 'filter'\n      let result = msg.payload\n\n      switch (msg.nodetype) {\n        case 'read':\n          result = node.filterByReadType(msg)\n          break\n        case 'write':\n          result = node.filterByWriteType(msg)\n          break\n        case 'listen':\n          result = node.filterByListenType(msg)\n          break\n        default:\n          if (node.showErrors) {\n            node.error(new Error('unknown node type injected to filter for ' + msg.nodetype), msg)\n          }\n          coreFilter.internalDebugLog('unknown node type injected to filter for ' + msg.nodetype)\n      }\n\n      if (result === undefined || result === null) {\n        coreFilter.internalDebugLog('result null or undefined' + JSON.stringify(msg))\n        return\n      }\n\n      if (result.hasOwnProperty('value')) {\n        result = result.value\n      }\n\n      let resultDataType = typeof result\n      if (result.hasOwnProperty('datatype')) {\n        resultDataType = result.datatype || typeof result\n      }\n\n      if (resultDataType && resultDataType.toString() !== node.datatype.toString()) {\n        result = node.convertDataType(result)\n      }\n\n      if (result === undefined || result === null) {\n        if (node.showErrors) {\n          node.error(new Error('converted result null or undefined'), msg)\n        }\n      } else {\n        try {\n          if (node.fixPoint >= 0 && node.fixedValue) {\n            result = Number.parseFloat(result).toFixed(node.fixPoint)\n            result = parseFloat(result)\n          }\n\n          if (node.precision >= 0 && node.withPrecision) {\n            result = Number.parseFloat(result).toPrecision(node.precision)\n            result = parseFloat(result)\n          }\n\n          if (node.withValueCheck) {\n            if (result < node.minvalue || result > node.maxvalue) {\n              result = node.defaultvalue\n            }\n          }\n        } catch (err) {\n          if (node.showErrors) {\n            node.error(err, msg)\n          }\n        }\n      }\n\n      if (node.justValue) {\n        node.send({payload: result, topic: node.topic || msg.topic, nodeId: node.nodeId})\n      } else {\n        node.send({payload: result, topic: node.topic || msg.topic, nodeId: node.nodeId, input: msg})\n      } // here node topic first to overwrite for dashboard\n    })\n\n    node.filterByReadType = function (msg) {\n      let result = null\n\n      if (msg.payload.length >= node.entry) {\n        result = node.extractValueFromOPCUAArrayStructure(msg, node.entry - 1)\n      } else {\n        result = node.extractValueFromOPCUAStructure(msg)\n      }\n\n      if (result.hasOwnProperty('value')) {\n        result = result.value\n      }\n\n      return result\n    }\n\n    node.extractValueFromOPCUAArrayStructure = function (msg, entryIndex) {\n      let result = null\n      let payload = msg.payload[entryIndex]\n\n      if (!payload) {\n        return result\n      }\n\n      if (payload.hasOwnProperty('value')) {\n        if (payload.value.hasOwnProperty('value')) {\n          result = payload.value.value\n        } else {\n          result = payload.value\n        }\n      } else {\n        result = payload\n      }\n\n      return result\n    }\n\n    node.extractValueFromOPCUAStructure = function (msg) {\n      let result = null\n\n      if (msg.payload.hasOwnProperty('value')) {\n        if (msg.payload.value.hasOwnProperty('value')) {\n          result = msg.payload.value.value\n        } else {\n          result = msg.payload.value\n        }\n      } else {\n        result = msg.payload\n      }\n\n      return result\n    }\n\n    node.filterByWriteType = function (msg) {\n      let result = null\n\n      if (msg.payload.hasOwnProperty('value')) {\n        result = msg.payload.value\n      } else {\n        result = msg.payload\n      }\n\n      if (result && result.hasOwnProperty('value')) {\n        result = result.value\n      }\n\n      return result\n    }\n\n    node.filterByListenType = function (msg) {\n      let result = null\n\n      if (msg.payload && msg.payload.hasOwnProperty('value')) {\n        result = msg.payload.value\n      } else {\n        result = msg.payload\n      }\n\n      if (result && result.hasOwnProperty('value')) {\n        result = result.value\n      }\n\n      return result\n    }\n\n    node.convertDataType = function (result) {\n      coreFilter.internalDebugLog('data type convert for ' + node.nodeId)\n      return coreFilter.core.convertDataValueByDataType({value: result}, node.datatype)\n    }\n\n    node.status({fill: 'green', shape: 'dot', text: 'active'})\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Result-Filter', OPCUAIIoTResultFilter)\n}\n"]}